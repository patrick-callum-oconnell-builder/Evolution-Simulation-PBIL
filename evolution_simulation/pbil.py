"""
Simple Python wrapper for the existing PBIL C implementation.

This wrapper calls the original pbil_c.c main function via subprocess,
providing a clean Python interface while preserving the original C implementation.
"""

import subprocess
import os
import sys
import re
from typing import Dict, Any, Optional, List, Tuple
import tempfile


class PBILWrapper:
    """
    A simple but robust wrapper around the existing PBIL C implementation.
    
    This class provides a Python interface to the original C code without
    modifying the underlying implementation.
    """
    
    def __init__(self, executable_path: Optional[str] = None):
        """
        Initialize the PBIL wrapper.
        
        Args:
            executable_path: Path to the compiled PBIL executable. 
                           If None, will try to find or compile it.
        """
        self.executable_path = executable_path
        self._ensure_executable()
    
    def _ensure_executable(self):
        """Ensure the C executable exists and is compiled."""
        if self.executable_path and os.path.exists(self.executable_path):
            return
            
        # Try common locations
        possible_paths = [
            './pbil_c',
            'pbil_c', 
            './c_src/pbil_c',
            'c_src/pbil_c'
        ]
        
        for path in possible_paths:
            if os.path.exists(path):
                self.executable_path = path
                return
        
        # Try to compile it
        self._compile_executable()
    
    def _compile_executable(self):
        """Compile the C executable from source."""
        c_files = []
        if os.path.exists('c_src'):
            c_files = [f'c_src/{f}' for f in os.listdir('c_src') if f.endswith('.c')]
        
        if not c_files:
            raise RuntimeError("No C source files found. Please ensure c_src/ directory exists with .c files")
        
        # Compile command
        output_name = './pbil_c'
        compile_cmd = ['gcc', '-o', output_name] + c_files + ['-lm']
        
        try:
            result = subprocess.run(compile_cmd, capture_output=True, text=True, check=True)
            self.executable_path = output_name
            print(f"Successfully compiled PBIL executable: {output_name}")
        except subprocess.CalledProcessError as e:
            raise RuntimeError(f"Failed to compile C executable: {e.stderr}")
    
    def run(self, 
            pop_size: int = 100,
            learning_rate: float = 0.1,
            negative_learning_rate: float = 0.075,
            mutation_probability: float = 0.02,
            mutation_shift: float = 0.05,
            max_iterations: int = 1000,
            cnf_file: str = None,
            print_generations: bool = False) -> Dict[str, Any]:
        """
        Run the PBIL algorithm on a MAXSAT problem.
        
        Args:
            pop_size: Number of vectors generated by probability vector for each population
            learning_rate: Learning rate for updating probability vector
            negative_learning_rate: Negative learning rate (for worst individuals)
            mutation_probability: Probability of mutation for each bit
            mutation_shift: Amount by which mutation alters a bit
            max_iterations: Maximum number of iterations/generations
            cnf_file: Path to the .cnf file containing the MAXSAT problem
            print_generations: Whether to print generation-by-generation progress
            
        Returns:
            Dictionary containing results including best solution, fitness, etc.
        """
        if not cnf_file:
            raise ValueError("cnf_file is required")
        
        if not os.path.exists(cnf_file):
            raise FileNotFoundError(f"CNF file not found: {cnf_file}")
        
        # Prepare arguments for the C program
        args = [
            self.executable_path,
            str(pop_size),
            str(learning_rate),
            str(negative_learning_rate), 
            str(mutation_probability),
            str(mutation_shift),
            str(max_iterations),
            cnf_file,
            str(1 if print_generations else 0)
        ]
        
        try:
            # Run the C program and capture output
            result = subprocess.run(args, capture_output=True, text=True, check=True)
            
            # Parse the output to extract results
            return self._parse_output(result.stdout, cnf_file)
            
        except subprocess.CalledProcessError as e:
            raise RuntimeError(f"PBIL execution failed: {e.stderr}")
        except Exception as e:
            raise RuntimeError(f"Error running PBIL: {str(e)}")
    
    def _parse_output(self, output: str, cnf_file: str) -> Dict[str, Any]:
        """
        Parse the output from the C program to extract results.
        
        Args:
            output: Raw stdout from the C program
            cnf_file: Original CNF file path
            
        Returns:
            Parsed results dictionary
        """
        results = {
            'cnf_file': cnf_file,
            'output': output,
            'success': False
        }
        
        try:
            # Extract time elapsed
            time_match = re.search(r'Time elapsed: ([\d.]+) seconds', output)
            if time_match:
                results['time_elapsed'] = float(time_match.group(1))
            
            # Extract problem info
            problem_match = re.search(r'Results for problem .* \((\d+) variables, (\d+) clauses\)', output)
            if problem_match:
                results['n_variables'] = int(problem_match.group(1))
                results['n_clauses'] = int(problem_match.group(2))
            
            # Extract total generations
            gen_match = re.search(r'Total generations created: (\d+)', output)
            if gen_match:
                results['total_generations'] = int(gen_match.group(1))
            
            # Extract best solution
            solution_match = re.search(r'Best candidate solution found: <([^>]+)>', output)
            if solution_match:
                solution_str = solution_match.group(1).strip()
                results['best_solution'] = [int(x) for x in solution_str.split()]
            
            # Extract generation where best was found
            best_gen_match = re.search(r'at generation (\d+)', output)
            if best_gen_match:
                results['best_found_at_generation'] = int(best_gen_match.group(1))
            
            # Extract fitness
            fitness_match = re.search(r'satisfied (\d+) of (\d+) clauses \(([\d.]+)% fit\)', output)
            if fitness_match:
                results['fitness'] = int(fitness_match.group(1))
                results['max_fitness'] = int(fitness_match.group(2))
                results['fitness_percentage'] = float(fitness_match.group(3))
                results['success'] = results['fitness'] == results['max_fitness']
            
            # Check if optimal solution was found
            if 'Reached max fitness w/ candidate solution!' in output:
                results['optimal_found'] = True
            else:
                results['optimal_found'] = False
                
        except Exception as e:
            print(f"Warning: Error parsing output: {e}")
            # Still return what we have
            
        return results
    
    def run_multiple(self, cnf_files: List[str], **kwargs) -> List[Dict[str, Any]]:
        """
        Run PBIL on multiple CNF files with the same parameters.
        
        Args:
            cnf_files: List of CNF file paths
            **kwargs: Parameters passed to run()
            
        Returns:
            List of result dictionaries
        """
        results = []
        for cnf_file in cnf_files:
            try:
                result = self.run(cnf_file=cnf_file, **kwargs)
                results.append(result)
            except Exception as e:
                results.append({
                    'cnf_file': cnf_file,
                    'error': str(e),
                    'success': False
                })
        return results
    
    def print_results(self, results: Dict[str, Any]):
        """Pretty print the results from a PBIL run."""
        if not results.get('success') and 'error' in results:
            print(f"‚ùå Error: {results['error']}")
            return
            
        print(f"\nüìÅ Problem: {os.path.basename(results['cnf_file'])}")
        if 'n_variables' in results and 'n_clauses' in results:
            print(f"üìä Size: {results['n_variables']} variables, {results['n_clauses']} clauses")
        
        if 'time_elapsed' in results:
            print(f"‚è±Ô∏è  Time: {results['time_elapsed']:.2f} seconds")
        
        if 'total_generations' in results:
            print(f"üîÑ Generations: {results['total_generations']}")
        
        if 'fitness' in results and 'max_fitness' in results:
            print(f"üéØ Fitness: {results['fitness']}/{results['max_fitness']} ({results.get('fitness_percentage', 0):.2f}%)")
        
        if results.get('optimal_found'):
            print("‚úÖ Optimal solution found!")
        elif results.get('success'):
            print("‚úÖ Maximum fitness reached!")
        else:
            print("‚ö†Ô∏è  Did not reach optimal solution")
        
        if 'best_solution' in results:
            solution = results['best_solution']
            if len(solution) <= 20:
                print(f"üí° Solution: {solution}")
            else:
                print(f"üí° Solution: {solution[:10]}...{solution[-10:]} (showing first/last 10)")
        
        if 'best_found_at_generation' in results:
            print(f"üìà Best found at generation: {results['best_found_at_generation']}")


# Convenience function for simple usage
def run_pbil(cnf_file: str, **kwargs) -> Dict[str, Any]:
    """
    Convenience function to run PBIL with default parameters.
    
    Args:
        cnf_file: Path to CNF file
        **kwargs: Additional parameters passed to PBILWrapper.run()
        
    Returns:
        Results dictionary
    """
    wrapper = PBILWrapper()
    return wrapper.run(cnf_file=cnf_file, **kwargs)


if __name__ == "__main__":
    # Simple command line interface
    if len(sys.argv) < 2:
        print("Usage: python pbil.py <cnf_file> [args...]")
        print("\nExample:")
        print("  python pbil.py problem.cnf")
        print("  python pbil.py problem.cnf --pop-size 200 --max-iterations 2000")
        sys.exit(1)
    
    cnf_file = sys.argv[1]
    
    # Simple argument parsing
    kwargs = {}
    args = sys.argv[2:]
    i = 0
    while i < len(args):
        if args[i] == '--pop-size' and i + 1 < len(args):
            kwargs['pop_size'] = int(args[i + 1])
            i += 2
        elif args[i] == '--learning-rate' and i + 1 < len(args):
            kwargs['learning_rate'] = float(args[i + 1])
            i += 2
        elif args[i] == '--max-iterations' and i + 1 < len(args):
            kwargs['max_iterations'] = int(args[i + 1])
            i += 2
        elif args[i] == '--print-generations':
            kwargs['print_generations'] = True
            i += 1
        else:
            i += 1
    
    # Run PBIL
    wrapper = PBILWrapper()
    results = wrapper.run(cnf_file=cnf_file, **kwargs)
    wrapper.print_results(results) 